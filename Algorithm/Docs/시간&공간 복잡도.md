# **[Algorithm] 시간/공간 복잡도에 대하여**

## **# 알고리즘 성능 분석의 필요성**
    프로그램의 규모는 서비스가 진행되는 한 계속해서 방대해진다.(=처리 데이터 증가)
<p>

| 입력 데이터의 개수 | 알고리즘A (O(n2)) | 알고리즘B (O(2n)) |
| :----------------: | :---------------: | :---------------: |
|       n = 6        |       36초        |       64초        |
|      n = 100       |     10,000초      |  엄청 오래 걸림   |
    
입력한 데이터의 개수에 따라 서로 다른 알고리즘 A와 B의  프로세스 실행 속도 차이는 2배에서 몇백배까지도 차이가 난다.

결과적으로 알고리즘 A가 B보다 효율적인 알고리즘이라 할 수 있고 알고리즘 A같은 알고리즘을 작성할 수 있는 개발자가 되어야 훌륭한 개발자이다.
</P>

---
<br>

## **# 시간복잡도(=Time Complexity)**
> 시간 복잡도에 대한 자세한 정보는 Big-O 문서에서 다룹니다.
 
    - 시간복잡도는 알고리즘을 수행 할 때 수행되는 연산들을 몇번 이루어지는 지를 숫자로 표기는데 이때 사용하는 것이 Big-O표기법이다.

    - *연산의 개수를 입력한 데이터의 개수를 n, n을 함수로 나타낸 것을 T(n)이라 표기한다.   
*연산= 산술, 대입, 비교, 이동 등등...
    
---
<br>

## **# 공간복잡도(=Space Complexity)**

    공간복잡도는 '얼마나 많은 공간(메모리)를 차지하느냐'가 중요한 요점이다.

    즉, 프로그램 실행 후 완료하는 데 필요한 자원 공간의 양을 의미한다.

    예전에 비해 컴퓨터 성능의 발달로 중요도 떨어짐.
<br>

### ***재귀함수로 보는 공간복잡도**
```javascript
let fun = (n) => {
    if (n > 1) {
        return n * fun(n - 1);
        // (((4 * (4-1)) * (3-1)) * (2-1))
    } else {
        return 1; 
        // n=1 이면 1 반환 후 재귀호출 끝.
    }
};

console.log(fun2(4)); // 24
```
    위 경우 fun함수의 파라미터에 4의 값을 주어서 1이 될때까지 재귀 호출 되므로 스택에는 n부터 1까지 모두 쌓이며 공간 복잡도는 O(n)이 된다.

<br>

### ***공간복잡도를 줄이는 방법**
 
**[프로그램에 필요한 공간]**
- 고정 공간

- 가변 공간


**- 고정 공간보다는 가변 공간을 사용하는 자료구조 활용하기]**
  - 배열의 크기(길이) 동적 할당 주기
  
  - 재귀함수 보다는 반복문 사용하기