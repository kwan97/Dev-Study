# **[Algorithm] Big-O표기법에 대하여**

## **# Big-O 표기법**
    동전을 튕겨 뒷면이 나올 확률을 이야기 할 때 운이 좋으면 1번에 뒷면이 나오지만 운이 안 좋다면 n번 만큼 동전을 튕겨야 하는 경우가 발생합니다.

    이 최악의 경우를 계산하는 방식을 **Big-O 표기법**이라 부른다.
    
    연산의 개수를 입력한 데이터의 개수를 n, n을 함수로 나타낸 것을 T(n)이라 표기한다.
<br>

## **# Big-O 표기법 종류**

- **O(1):** 스택의 push, pop

- **O(n):** for문

- **O(log n):** 이진트리

- **O(n2):** 증첩 for문, 삽입정렬, 거품정렬, 선택정렬

- **O(2n):** 파보나치 수열

> **>>효율적인 시간복잡도 순서)**<br> 
**[Fast]**  O(1) = O(log n) -> O(n) -> O(n2) -> O(2n) -> O(n!)  **[slow]**

<br>

## ***O(1)**
    - 상수 시간(=Constant time)
    - n의 크기와 상관없이 로직 프로세스는 딱 하나

```javascript
//예제1)
const kwan = "hello";
console.log(kwan); //hello

//예제2)
const kwan = [1,2,3,4,5,6];
const index = 2;

const result = kwan[index];

console.log(result);
// 배열 원소가 백만개라 해도 인덱스 위지 지정하여 출력하는 시간에 아무 영향 없음
```
<br>

## **>> log에 대하여**
> O(log n)과 O(n log n)에 대해서 알아보기 전 log에 대해서 알아보자

- **지수(=exponent)와 역(=inverse)의 관계이다.**
  - log8은 2의 3승인 역이다.
  
- **2를 몇번 곱해야 n이 나올까? = log2**
  - 2를 세번 거듭제곱 해주면 8이 나온다 => log8 = 3 이다.

- **1이 될때까지 n을 몇번 2로 나눠줘야 할까? = log2** 
  - 8 / 2 / 2 / 2 = 1  ==  log8 = 3

<br>

## ***O(log n) == 이진 검색**
- 반씩 접어가며 접근하는 이진탐색 원리이다.

- 입력 크기(n)가 커질수록 처리 log n에 비례하여 짧아진다.

- '데이터 수의 증가율'에 비하여 '연산횟수의 증가율'이 훨씬 낮은 알고리즘

- 정렬되지 않은 배열에 사용 불가

- 데이터 원소가 n개 이면 알고리즘에 log2 단계가 걸린다고 생각하면 쉽다.

<br>

## ***O(n log n)**
- 데이터의 수가 2배로 늘때, 연산횟수는 2배 조금 넘게 증가한다.

- 입력의 절반(또는 일부)으로 나눌 때마다 각 부분을 독립적으로 처리

<br>

## ***O(n)**
- 선형 시간(=Linear time)

- 입력 크기(n)와 연산 횟수가 비례

- 즉, 연산횟수가 선형적으로 증가하는 형태

```javascript
function sample(n) {
    for (let i = 0; i <= n; i++){
        console.log(i);
        // i = n
    }
}
console.log(sample(5));
```
<br>

## ***O(n2)**
- 중첩 반복이 있는 로직을 뜻하며 쉽게 풀어 2차 시간이라고 한다.( O(n3)는 3차시간...) 

- 입력 크기(n)가 커질 때 연산 횟수가 n의 제곱수로 증가한다.(10배 -> 100배)

- 이런 알고리즘은 각 원소를 다른 모든 원소와 비교

```javascript
function test(n) {
    for (let i = 2; i <= n; i++) {
        // console.log('i의 값: ',i)

        for (let j = 1; j <= n; j++) {
            // console.log('j의 값: ',j)
            console.log(`구구단을 외우자 ${i} X ${j} = `,i*j)
        }
    }
}
test(9); // 1~9단 까지 출력(입력값 제곱 = 총 81개의 구구단식)
```
<br>

## ***O(2n)**
- 데이터량이 많아질수록 처리시간이 가하급수적으로 늘어나는 것.
   
- 파보나치 수열, 재귀의 역기능

```javascript
int func (int n) {
  if (n <= 1) 
    return n;
  return func(n-1) + fun(n-2);
}
```
